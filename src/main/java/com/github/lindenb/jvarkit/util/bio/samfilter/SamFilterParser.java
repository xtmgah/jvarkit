/* SamFilterParser.java */
/* Generated By:JavaCC: Do not edit this line. SamFilterParser.java */
/*
The MIT License (MIT)

Copyright (c) 2020 Pierre Lindenbaum

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

/**

Note to self:

java -cp ~/package/javacc/javacc.jar javacc -OUTPUT_DIRECTORY=src/main/java/com/github/lindenb/jvarkit/util/bio/samfilter -JDK_VERSION=1.8 src/main/resources/javacc/com/github/lindenb/jvarkit/util/bio/samfilter/SamFilterParser.jj 

*/

package com.github.lindenb.jvarkit.util.bio.samfilter;


import htsjdk.samtools.SAMRecord;
import java.util.function.Predicate;
import com.github.lindenb.jvarkit.lang.StringUtils;


public class SamFilterParser implements SamFilterParserConstants {


                private final SamRecordFilterFactory factory = new SamRecordFilterFactory();

  final public Predicate<SAMRecord> anyNode() throws ParseException {Predicate<SAMRecord> other;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case NOT:{
      other = NegateExpr();
{if ("" != null) return other;}
      break;
      }
    case DUPLICATE:
    case UNMAPPED:
    case MAPPED:
    case MATEUNMAPPED:
    case FAILSVENDORQUALITY:
    case NOTPRIMARYALIGNMENT:
    case SUPPLEMENTARYALIGNMENT:
    case PAIRED:
    case CLIPPED:
    case MAPQUNAVAILABLE:
    case OVERLAP:
    case SAMFLAG:
    case SAMPLE:
    case GROUP:
    case HASFLAG:
    case DISCORDANT:
    case MAPQLT:{
      other = OrExpr();
{if ("" != null) return other;}
      break;
      }
    case OPAR:{
      jj_consume_token(OPAR);
      other = anyNode();
      jj_consume_token(CPAR);
{if ("" != null) return other;}
      break;
      }
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private Predicate<SAMRecord> NegateExpr() throws ParseException {Predicate<SAMRecord> root;
    jj_consume_token(NOT);
    root = OrExpr();
{if ("" != null) return root.negate();}
    throw new Error("Missing return statement in function");
  }

  final private Predicate<SAMRecord> OrExpr() throws ParseException {Predicate<SAMRecord> root,other;
    root = AndExpr();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case OR:{
        ;
        break;
        }
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      jj_consume_token(OR);
      other = AndExpr();
root = root.or(other);
    }
{if ("" != null) return root;}
    throw new Error("Missing return statement in function");
  }

  final private Predicate<SAMRecord> AndExpr() throws ParseException {Predicate<SAMRecord> root,other;
    root = UnaryExpr();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case AND:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      jj_consume_token(AND);
      other = UnaryExpr();
root = root.and(other);
    }
{if ("" != null) return root;}
    throw new Error("Missing return statement in function");
  }

  final private Predicate<SAMRecord> UnaryExpr() throws ParseException {String str; Token t; int flg;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case DUPLICATE:{
      jj_consume_token(DUPLICATE);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.duplicateFilter();}
      break;
      }
    case UNMAPPED:{
      jj_consume_token(UNMAPPED);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.unmappedFilter();}
      break;
      }
    case MAPPED:{
      jj_consume_token(MAPPED);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.mappedFilter();}
      break;
      }
    case FAILSVENDORQUALITY:{
      jj_consume_token(FAILSVENDORQUALITY);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.failsVendorQuality();}
      break;
      }
    case PAIRED:{
      jj_consume_token(PAIRED);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.readPaired();}
      break;
      }
    case CLIPPED:{
      jj_consume_token(CLIPPED);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.readClipped();}
      break;
      }
    case MAPQUNAVAILABLE:{
      jj_consume_token(MAPQUNAVAILABLE);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.mapqUnavailable();}
      break;
      }
    case MATEUNMAPPED:{
      jj_consume_token(MATEUNMAPPED);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.mateUnmapped();}
      break;
      }
    case NOTPRIMARYALIGNMENT:{
      jj_consume_token(NOTPRIMARYALIGNMENT);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.notPrimaryAlignmentFlag();}
      break;
      }
    case SUPPLEMENTARYALIGNMENT:{
      jj_consume_token(SUPPLEMENTARYALIGNMENT);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.supplementaryAlignmentFlag();}
      break;
      }
    case OVERLAP:{
      jj_consume_token(OVERLAP);
      jj_consume_token(OPAR);
      str = characters();
      jj_consume_token(CPAR);
{if ("" != null) return factory.overlapBed(str);}
      break;
      }
    case SAMFLAG:{
      jj_consume_token(SAMFLAG);
      jj_consume_token(OPAR);
      t = jj_consume_token(INT);
      jj_consume_token(CPAR);
{if ("" != null) return factory.samFlag(Integer.parseInt(t.image));}
      break;
      }
    case SAMPLE:{
      jj_consume_token(SAMPLE);
      jj_consume_token(OPAR);
      str = characters();
      jj_consume_token(CPAR);
{if ("" != null) return factory.sample(str);}
      break;
      }
    case GROUP:{
      jj_consume_token(GROUP);
      jj_consume_token(OPAR);
      str = characters();
      jj_consume_token(CPAR);
{if ("" != null) return factory.group(str);}
      break;
      }
    case HASFLAG:{
      jj_consume_token(HASFLAG);
      jj_consume_token(OPAR);
      flg = integer();
      jj_consume_token(CPAR);
{if ("" != null) return factory.hasFlag(flg);}
      break;
      }
    case DISCORDANT:{
      jj_consume_token(DISCORDANT);
      jj_consume_token(OPAR);
      jj_consume_token(CPAR);
{if ("" != null) return factory.discordant();}
      break;
      }
    case MAPQLT:{
      jj_consume_token(MAPQLT);
      jj_consume_token(OPAR);
      flg = integer();
      jj_consume_token(CPAR);
{if ("" != null) return factory.mapqLowerThan(flg);}
      break;
      }
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private String characters() throws ParseException {Token t;
    switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
    case SIMPLE_QUOTE_LITERAL:{
      t = jj_consume_token(SIMPLE_QUOTE_LITERAL);
{if ("" != null) return  StringUtils.unescapeC(t.image.substring(1,t.image.length()-1));}
      break;
      }
    case DOUBLE_QUOTE_LITERAL:{
      t = jj_consume_token(DOUBLE_QUOTE_LITERAL);
{if ("" != null) return StringUtils.unescapeC(t.image.substring(1,t.image.length()-1));}
      break;
      }
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final private int integer() throws ParseException {Token t;
    t = jj_consume_token(INT);
{if ("" != null) return  Integer.parseInt(t.image);}
    throw new Error("Missing return statement in function");
  }

  /** Generated Token Manager. */
  public SamFilterParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[5];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xfffc1400,0x100,0x200,0xfffc0000,0x30000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x7,0x0,0x0,0x7,0x0,};
   }

  /** Constructor with InputStream. */
  public SamFilterParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public SamFilterParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new SamFilterParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public SamFilterParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new SamFilterParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public SamFilterParser(SamFilterParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(SamFilterParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 5; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk_f() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[35];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 5; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 35; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

        }
